import hashlib
import os
import random
from typing import List

from Crypto.Cipher import AES
from Crypto.PublicKey import RSA
from Crypto.Random import get_random_bytes
from Crypto.Util.number import GCD, bytes_to_long, inverse, long_to_bytes

# Constants
DEFAULT_BLOCK_SIZE = 4096
DEFAULT_PRF_KEY_SIZE = 16
DEFAULT_PRP_KEY_SIZE = 16
DEFAULT_RSA_KEY_SIZE = 1024


class ApdpError(Exception):
    """Custom exception for APDP-related errors."""

    pass


class CryptographicUtils:
    """Utility class for cryptographic operations."""

    @staticmethod
    def full_domain_hash(rsa_key, data: bytes) -> int:
        if rsa_key is None or data is None:
            raise ApdpError("Invalid parameters for full_domain_hash")
        hashed = hashlib.sha256(data).digest()
        return bytes_to_long(hashed) % rsa_key.n

    @staticmethod
    def prf_aes(key: bytes, input_int: int, out_len=16) -> bytes:
        if not key or len(key) == 0:
            raise ApdpError("Invalid key for PRF")
        cipher = AES.new(key, AES.MODE_ECB)
        block = long_to_bytes(input_int, out_len)
        return cipher.encrypt(block)

    @staticmethod
    def prf_f(key: bytes, index: int) -> bytes:
        if key is None:
            raise ApdpError("No key provided to PRF")
        return CryptographicUtils.prf_aes(key, index, len(key))

    @staticmethod
    def generate_prp_indices(key: bytes, num_blocks: int, c: int) -> List[int]:
        if key is None or num_blocks <= 0 or c <= 0:
            raise ApdpError("Invalid parameters for generate_prp_indices")
        indices = set()
        counter = 0
        while len(indices) < c:
            val_block = CryptographicUtils.prf_f(key, counter)
            val = bytes_to_long(val_block)
            indices.add(val % num_blocks)
            counter += 1
        return list(indices)


class APDPKey:
    """Represents the key structure used in the APDP protocol."""

    def __init__(self):
        self.rsa = None
        self.g = None
        self.prf_key = None

    def generate(self, rsa_bits=DEFAULT_RSA_KEY_SIZE):
        if rsa_bits <= 0:
            raise ApdpError("Invalid RSA key size")
        self.rsa = RSA.generate(rsa_bits)
        if self.rsa is None:
            raise ApdpError("Failed to generate RSA key")

        # Choose g
        for _ in range(1000):
            candidate = random.randint(2, self.rsa.n - 2)
            g_candidate = pow(candidate, 2, self.rsa.n)
            if g_candidate not in (0, 1):
                self.g = g_candidate
                break
        if self.g is None:
            raise ApdpError("Failed to find suitable generator g")

        self.prf_key = get_random_bytes(DEFAULT_PRF_KEY_SIZE)
        if self.prf_key is None:
            raise ApdpError("Failed to generate PRF key")

    def clear(self):
        self.rsa = None
        self.g = None
        self.prf_key = None


class APDPTag:
    """Represents a tag generated for a block of data."""

    def __init__(self, index: int, tag_value: int, prf_value: bytes):
        self.index = index
        self.tag_value = tag_value
        self.prf_value = prf_value


class Challenge:
    """Represents a challenge issued by the validator."""

    def __init__(self, num_blocks, prp_key: bytes, prf_key: bytes, s: int, g_s: int):
        if num_blocks <= 0 or not prp_key or not prf_key:
            raise ApdpError("Invalid challenge parameters")
        self.num_blocks = num_blocks
        self.prp_key = prp_key
        self.prf_key = prf_key
        self.s = s
        self.g_s = g_s


class Proof:
    """Represents a proof generated by the miner."""

    def __init__(
        self, aggregated_tag: int, aggregated_blocks: int, hashed_result: bytes
    ):
        self.aggregated_tag = aggregated_tag
        self.aggregated_blocks = aggregated_blocks
        self.hashed_result = hashed_result


class ChallengeSystem:
    """Encapsulates the APDP system for validator and miner operations."""

    def __init__(self, block_size: int = DEFAULT_BLOCK_SIZE):
        self.key = APDPKey()
        self.block_size = block_size

    def initialize_keys(self, rsa_bits=DEFAULT_RSA_KEY_SIZE):
        """Initialize validator with keys."""
        if rsa_bits <= 0:
            raise ApdpError("RSA bits must be positive")
        self.key.generate(rsa_bits)

    def generate_tags(self, data: bytes) -> List[APDPTag]:
        """Generate tags for each block of data."""
        if self.key.rsa is None or self.key.g is None or self.key.prf_key is None:
            raise ApdpError("Keys are not initialized")

        if data is None or len(data) == 0:
            raise ApdpError("No data to generate tags")

        num_blocks = (len(data) + self.block_size - 1) // self.block_size
        if num_blocks == 0:
            raise ApdpError("No blocks computed from the given data")

        tags = []

        for index in range(num_blocks):
            block = data[index * self.block_size : (index + 1) * self.block_size]
            block_int = bytes_to_long(block.ljust(self.block_size, b"\x00"))

            prf_value = CryptographicUtils.prf_f(self.key.prf_key, index)
            fdh_hash = CryptographicUtils.full_domain_hash(self.key.rsa, prf_value)

            phi = (self.key.rsa.p - 1) * (self.key.rsa.q - 1)
            block_int %= phi

            # Check for zero or invalid parameters
            if phi <= 0:
                raise ApdpError("Invalid RSA parameters")

            try:
                base = (
                    fdh_hash * pow(self.key.g, block_int, self.key.rsa.n)
                ) % self.key.rsa.n
                tag_value = pow(base, self.key.rsa.d, self.key.rsa.n)
            except ValueError:
                raise ApdpError("Failed to compute tag value")

            tags.append(APDPTag(index, tag_value, prf_value))

        return tags

    def issue_challenge(self, num_blocks: int) -> Challenge:
        """Issue a challenge to the miner."""
        if self.key.rsa is None or self.key.g is None:
            raise ApdpError("Keys are not initialized")

        if num_blocks <= 0:
            raise ApdpError("Number of blocks must be positive")

        s = random.randint(2, self.key.rsa.n - 1)
        # Ensure s is in Z*_n
        attempt_count = 0
        while GCD(s, self.key.rsa.n) != 1:
            s = random.randint(2, self.key.rsa.n - 1)
            attempt_count += 1
            if attempt_count > 10000:
                raise ApdpError("Failed to find suitable s in Z*_n")

        g_s = pow(self.key.g, s, self.key.rsa.n)
        prp_key = get_random_bytes(DEFAULT_PRP_KEY_SIZE)
        prf_key = get_random_bytes(DEFAULT_PRF_KEY_SIZE)

        return Challenge(num_blocks, prp_key, prf_key, s, g_s)

    def generate_proof(
        self, data: bytes, tags: List[APDPTag], challenge: Challenge
    ) -> Proof:
        """Generate a proof for the given challenge."""
        if not tags or challenge is None:
            raise ApdpError("Invalid tags or challenge for proof generation")

        if len(tags) < challenge.num_blocks:
            raise ApdpError("Not enough tags to satisfy challenge")

        indices = CryptographicUtils.generate_prp_indices(
            challenge.prp_key, len(tags), challenge.num_blocks
        )

        aggregated_tag = 1
        aggregated_blocks = 0

        for j, index in enumerate(indices):
            if index < 0 or index >= len(tags):
                raise ApdpError("Invalid block index in challenge")

            block = data[index * self.block_size : (index + 1) * self.block_size]
            block_int = bytes_to_long(block.ljust(self.block_size, b"\x00"))

            prf_result = CryptographicUtils.prf_f(challenge.prf_key, j)
            coefficient = bytes_to_long(prf_result) % self.key.rsa.n

            tag = tags[index]
            # Safeguard against invalid tag
            if tag is None or tag.tag_value is None:
                raise ApdpError("Missing or invalid tag")

            try:
                aggregated_tag = (
                    aggregated_tag * pow(tag.tag_value, coefficient, self.key.rsa.n)
                ) % self.key.rsa.n
            except ValueError:
                raise ApdpError("Failed to aggregate tag")

            aggregated_blocks += coefficient * block_int

        rho_temp = pow(challenge.g_s, aggregated_blocks, self.key.rsa.n)
        hashed_result = hashlib.sha256(long_to_bytes(rho_temp)).digest()

        return Proof(aggregated_tag, aggregated_blocks, hashed_result)

    def verify_proof(
        self, proof: Proof, challenge: Challenge, tags: List[APDPTag]
    ) -> bool:
        """Verify the proof returned by the miner."""
        if proof is None or challenge is None or not tags:
            raise ApdpError("Invalid proof, challenge, or tags")

        if self.key.rsa is None:
            raise ApdpError("Keys not initialized")

        try:
            tau = pow(proof.aggregated_tag, self.key.rsa.e, self.key.rsa.n)
        except ValueError:
            raise ApdpError("Failed to compute tau")

        indices = CryptographicUtils.generate_prp_indices(
            challenge.prp_key, len(tags), challenge.num_blocks
        )

        denominator = 1
        for j, index in enumerate(indices):
            if index < 0 or index >= len(tags):
                raise ApdpError("Invalid index during verification")

            prf_result = CryptographicUtils.prf_f(challenge.prf_key, j)
            coefficient = bytes_to_long(prf_result) % self.key.rsa.n
            prf_value = tags[index].prf_value
            fdh_hash = CryptographicUtils.full_domain_hash(self.key.rsa, prf_value)
            denominator = (
                denominator * pow(fdh_hash, coefficient, self.key.rsa.n)
            ) % self.key.rsa.n

        try:
            denominator_inv = inverse(denominator, self.key.rsa.n)
        except ValueError:
            raise ApdpError("Failed to invert denominator modulo n")

        tau = (tau * denominator_inv) % self.key.rsa.n

        tau_s = pow(tau, challenge.s, self.key.rsa.n)
        expected_hash = hashlib.sha256(long_to_bytes(tau_s)).digest()

        return expected_hash == proof.hashed_result


if __name__ == "__main__":
    try:
        data = os.urandom(1024 * 10)  # 10 KiB of random data

        system = ChallengeSystem()
        system.initialize_keys()
        print("Validator initialized with RSA key size", system.key.rsa.size_in_bits())

        tags = system.generate_tags(data)
        print("Tags generated for", len(tags), "blocks.")
        challenge = system.issue_challenge(len(tags))
        print("Challenge issued with", challenge.num_blocks, "challenges.")

        proof = system.generate_proof(data, tags, challenge)
        print("Proof generated.")
        print("Hashed result:", proof.hashed_result.hex())
        result = system.verify_proof(proof, challenge, tags)

        print("Proof verification:", "Success" if result else "Failure")
    except ApdpError as e:
        print("APDP Error Occurred:", e)
    except Exception as e:
        print("Unexpected Error:", e)
