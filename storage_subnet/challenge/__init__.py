import hashlib
import hmac
import os
import random
from math import gcd

from cryptography.fernet import Fernet
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.utils import int_to_bytes

# Constants
DEFAULT_RSA_KEY_SIZE = 2048


class APDPError(Exception):
    """Custom exception for APDP-related errors."""

    pass


class CryptoUtils:
    """Utility class for cryptographic operations."""

    @staticmethod
    def generate_rsa_private_key(key_size: int) -> rsa.RSAPrivateKey:
        return rsa.generate_private_key(public_exponent=65537, key_size=key_size)

    @staticmethod
    def full_domain_hash(rsa_key: rsa.RSAPrivateKey, data: bytes) -> int:
        if rsa_key is None or data is None:
            raise APDPError("Invalid parameters for full_domain_hash")
        hashed = hashlib.sha256(data).digest()
        return int.from_bytes(hashed, "big") % rsa_key.public_key().public_numbers().n

    @staticmethod
    def prf(key: bytes, input_int: int, out_len=16) -> bytes:
        """
        Psuedo-random function using HMAC-SHA256

        Arguments:
            key (bytes): Key used for encryption
            input_int (int): Input integer to encrypt
            out_len (int): Length of output block

        Returns:
            bytes: Encrypted block
        """
        if not key or len(key) == 0:
            raise APDPError("Invalid key for PRF")
        block = int_to_bytes(input_int, out_len)
        return hmac.digest(key, block, hashlib.sha256)

    @staticmethod
    def generate_prp_indices(key: bytes, num_blocks: int, c: int) -> list[int]:
        """
        Generate c unique indices from [0, num_blocks-1] using prf
        Arguments:
            key (bytes):
            num_blocks (int):
            c (int):

        Returns:
            list[int]: The list of c unique indices
        """
        if key is None or num_blocks <= 0 or c <= 0:
            raise APDPError("Invalid parameters for generate_prp_indices")
        indices = set()
        counter = 0
        while len(indices) < c:
            val_block = CryptoUtils.prf(key, counter)
            val = int.from_bytes(val_block, "big")
            indices.add(val % num_blocks)
            counter += 1
        return list(indices)


class APDPKey:
    """Represents the key structure used in the APDP protocol."""

    def __init__(self):
        self.rsa = None
        self.g = None
        self.prf_key = None

    def generate(self, rsa_bits=DEFAULT_RSA_KEY_SIZE):
        if rsa_bits <= 0:
            raise APDPError("Invalid RSA key size")
        self.rsa = rsa.generate_private_key(public_exponent=65537, key_size=rsa_bits)
        if self.rsa is None:
            raise APDPError("Failed to generate RSA key")

        n = self.rsa.public_key().public_numbers().n
        # Choose g
        for _ in range(1000):
            candidate = random.randint(2, n - 2)
            g_candidate = pow(candidate, 2, n)
            if g_candidate not in (0, 1):
                self.g = g_candidate
                break
        if self.g is None:
            raise APDPError("Failed to find suitable generator g")

        # Generate a random key for Fernet-based PRF (32 bytes).
        self.prf_key = Fernet.generate_key()
        if self.prf_key is None:
            raise APDPError("Failed to generate PRF key")

    def clear(self):
        self.rsa = None
        self.g = None
        self.prf_key = None


class APDPTag:
    """Represents a tag generated for a block of data."""

    def __init__(self, index: int, tag_value: int, prf_value: bytes):
        self.index = index
        self.tag_value = tag_value
        self.prf_value = prf_value


class Challenge:
    """Represents a challenge issued by the validator."""

    def __init__(self, num_blocks, prp_key: bytes, prf_key: bytes, s: int, g_s: int):
        if num_blocks <= 0 or not prp_key or not prf_key:
            raise APDPError("Invalid challenge parameters")
        self.num_blocks = num_blocks
        self.prp_key = prp_key
        self.prf_key = prf_key
        self.s = s
        self.g_s = g_s


class Proof:
    """Represents a proof generated by the miner."""

    def __init__(
        self, aggregated_tag: int, aggregated_blocks: int, hashed_result: bytes
    ):
        self.aggregated_tag = aggregated_tag
        self.aggregated_blocks = aggregated_blocks
        self.hashed_result = hashed_result


class ChallengeSystem:
    """Encapsulates the APDP system for validator and miner operations."""

    def __init__(self, block_size: int):
        self.key = APDPKey()
        self.block_size = block_size

    def initialize_keys(self, rsa_bits=DEFAULT_RSA_KEY_SIZE):
        """Initialize validator with keys."""
        if rsa_bits <= 0:
            raise APDPError("RSA bits must be positive")
        self.key.generate(rsa_bits)

    def generate_tags(self, data: bytes) -> list[APDPTag]:
        """Generate tags for each block of data."""
        if self.key.rsa is None or self.key.g is None or self.key.prf_key is None:
            raise APDPError("Keys are not initialized")

        if data is None or len(data) == 0:
            raise APDPError("No data to generate tags")

        num_blocks = (len(data) + self.block_size - 1) // self.block_size
        if num_blocks == 0:
            raise APDPError("No blocks computed from the given data")

        tags = []

        n = self.key.rsa.public_key().public_numbers().n
        phi = (self.key.rsa.private_numbers().p - 1) * (
            self.key.rsa.private_numbers().q - 1
        )

        if phi <= 0:
            raise APDPError("Invalid RSA parameters")

        for index in range(num_blocks):
            block = data[index * self.block_size : (index + 1) * self.block_size]
            block_int = int.from_bytes(block.ljust(self.block_size, b"\x00"), "big")

            # PRF value for the block index
            prf_value = CryptoUtils.prf(self.key.prf_key, index)
            fdh_hash = CryptoUtils.full_domain_hash(self.key.rsa, prf_value)
            block_int %= phi

            # # Check for zero or invalid parameters
            # if phi <= 0:
            #     raise APDPError("Invalid RSA parameters")

            try:
                base = (fdh_hash * pow(self.key.g, block_int, n)) % n
                d = self.key.rsa.private_numbers().d
                tag_value = pow(base, d, n)
            except ValueError:
                raise APDPError("Failed to compute tag value")

            tags.append(APDPTag(index, tag_value, prf_value))

        return tags

    def issue_challenge(self, num_blocks: int) -> Challenge:
        """Issue a challenge to the miner."""
        if self.key.rsa is None or self.key.g is None:
            raise APDPError("Keys are not initialized")

        if num_blocks <= 0:
            raise APDPError("Number of blocks must be positive")

        n = self.key.rsa.public_key().public_numbers().n
        s = random.randint(2, n - 1)
        # Ensure s is in Z*_n
        attempt_count = 0
        while gcd(s, n) != 1:
            s = random.randint(2, n - 1)
            attempt_count += 1
            if attempt_count > 10000:
                raise APDPError("Failed to find suitable s in Z*_n")

        g_s = pow(self.key.g, s, n)
        prp_key = Fernet.generate_key()
        prf_key = Fernet.generate_key()

        return Challenge(num_blocks, prp_key, prf_key, s, g_s)

    def generate_proof(
        self, data: bytes, tags: list[APDPTag], challenge: Challenge
    ) -> Proof:
        """Generate a proof for the given challenge."""
        if not tags or challenge is None:
            raise APDPError("Invalid tags or challenge for proof generation")

        if len(tags) < challenge.num_blocks:
            raise APDPError("Not enough tags to satisfy challenge")

        n = self.key.rsa.public_key().public_numbers().n

        indices = CryptoUtils.generate_prp_indices(
            challenge.prp_key, len(tags), challenge.num_blocks
        )

        aggregated_tag = 1
        aggregated_blocks = 0

        for j, index in enumerate(indices):
            if index < 0 or index >= len(tags):
                raise APDPError("Invalid block index in challenge")

            block = data[index * self.block_size : (index + 1) * self.block_size]
            block_int = int.from_bytes(block.ljust(self.block_size, b"\x00"), "big")

            prf_result = CryptoUtils.prf(challenge.prf_key, j)
            coefficient = int.from_bytes(prf_result) % n

            tag = tags[index]
            # Safeguard against invalid tag
            if tag is None or tag.tag_value is None:
                raise APDPError("Missing or invalid tag")

            try:
                aggregated_tag = (
                    aggregated_tag * pow(tag.tag_value, coefficient, n)
                ) % n
            except ValueError:
                raise APDPError("Failed to aggregate tag")

            aggregated_blocks += coefficient * block_int

        rho_temp = pow(challenge.g_s, aggregated_blocks, n)
        hashed_result = hashlib.sha256(int_to_bytes(rho_temp)).digest()

        return Proof(aggregated_tag, aggregated_blocks, hashed_result)

    def verify_proof(
        self, proof: Proof, challenge: Challenge, tags: list[APDPTag]
    ) -> bool:
        """Verify the proof returned by the miner."""
        if proof is None or challenge is None or not tags:
            raise APDPError("Invalid proof, challenge, or tags")

        if self.key.rsa is None:
            raise APDPError("Keys not initialized")

        n = self.key.rsa.public_key().public_numbers().n
        e = self.key.rsa.public_key().public_numbers().e

        try:
            tau = pow(proof.aggregated_tag, e, n)
        except ValueError:
            raise APDPError("Failed to compute tau")

        indices = CryptoUtils.generate_prp_indices(
            challenge.prp_key, len(tags), challenge.num_blocks
        )

        denominator = 1
        for j, index in enumerate(indices):
            if index < 0 or index >= len(tags):
                raise APDPError("Invalid index during verification")

            prf_result = CryptoUtils.prf(challenge.prf_key, j)
            coefficient = int.from_bytes(prf_result, "big") % n
            prf_value = tags[index].prf_value
            fdh_hash = CryptoUtils.full_domain_hash(self.key.rsa, prf_value)
            denominator = (denominator * pow(fdh_hash, coefficient, n)) % n

        try:
            denominator_inv = pow(denominator, -1, n)
        except ValueError:
            raise APDPError("Failed to invert denominator modulo n")

        tau = (tau * denominator_inv) % n

        tau_s = pow(tau, challenge.s, n)
        expected_hash = hashlib.sha256(int_to_bytes(tau_s)).digest()

        return expected_hash == proof.hashed_result


if __name__ == "__main__":
    try:
        data = os.urandom(1024 * 2)  # 10 KiB of random data

        system = ChallengeSystem(block_size=1024)
        system.initialize_keys()
        print("Validator initialized with RSA key size", system.key.rsa.key_size)

        tags = system.generate_tags(data)
        print("Tags generated for", len(tags), "blocks.")
        challenge = system.issue_challenge(len(tags))
        print("Challenge issued with", challenge.num_blocks, "challenges.")

        proof = system.generate_proof(data, tags, challenge)
        print("Proof generated.")
        print("Hashed result:", proof.hashed_result.hex())
        result = system.verify_proof(proof, challenge, tags)

        print("Proof verification:", "Success" if result else "Failure")
    except APDPError as e:
        print("APDP Error Occurred:", e)
    except Exception as e:
        print("Unexpected Error:", e)
